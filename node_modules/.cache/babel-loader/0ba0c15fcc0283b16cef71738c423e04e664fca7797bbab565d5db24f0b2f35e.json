{"ast":null,"code":"import * as React from 'react';\nimport { getIntrinsicElementProps, useEventCallback, useMergedRefs, slot } from '@fluentui/react-utilities';\nimport { useArrowNavigationGroup, useFocusFinders } from '@fluentui/react-tabster';\nimport { useFluent_unstable as useFluent } from '@fluentui/react-shared-contexts';\nimport { interactionTagSecondaryClassNames } from '../InteractionTagSecondary/useInteractionTagSecondaryStyles.styles';\n/**\n * Create the state required to render TagGroup.\n *\n * The returned state can be modified with hooks such as useTagGroupStyles_unstable,\n * before being passed to renderTagGroup_unstable.\n *\n * @param props - props from this instance of TagGroup\n * @param ref - reference to root HTMLDivElement of TagGroup\n */\nexport const useTagGroup_unstable = (props, ref) => {\n  const {\n    onDismiss,\n    size = 'medium'\n  } = props;\n  const innerRef = React.useRef();\n  const {\n    targetDocument\n  } = useFluent();\n  const {\n    findNextFocusable,\n    findPrevFocusable\n  } = useFocusFinders();\n  const handleTagDismiss = useEventCallback((e, data) => {\n    var _innerRef_current;\n    onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(e, data);\n    // set focus after tag dismiss\n    const activeElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement;\n    if ((_innerRef_current = innerRef.current) === null || _innerRef_current === void 0 ? void 0 : _innerRef_current.contains(activeElement)) {\n      // focus on next tag only if the active element is within the current tag group\n      const next = findNextFocusable(activeElement, {\n        container: innerRef.current\n      });\n      if (next) {\n        next.focus();\n        return;\n      }\n      // if there is no next focusable, focus on the previous focusable\n      if (activeElement === null || activeElement === void 0 ? void 0 : activeElement.className.includes(interactionTagSecondaryClassNames.root)) {\n        const prev = findPrevFocusable(activeElement.parentElement, {\n          container: innerRef.current\n        });\n        prev === null || prev === void 0 ? void 0 : prev.focus();\n      } else {\n        const prev = findPrevFocusable(activeElement, {\n          container: innerRef.current\n        });\n        prev === null || prev === void 0 ? void 0 : prev.focus();\n      }\n    }\n  });\n  const arrowNavigationProps = useArrowNavigationGroup({\n    circular: true,\n    axis: 'both',\n    memorizeCurrent: true\n  });\n  return {\n    handleTagDismiss,\n    size,\n    components: {\n      root: 'div'\n    },\n    root: slot.always(getIntrinsicElementProps('div', {\n      // FIXME:\n      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`\n      // but since it would be a breaking change to fix it, we are casting ref to it's proper type\n      ref: useMergedRefs(ref, innerRef),\n      role: 'toolbar',\n      ...arrowNavigationProps,\n      ...props\n    }), {\n      elementType: 'div'\n    })\n  };\n};","map":{"version":3,"names":["React","getIntrinsicElementProps","useEventCallback","useMergedRefs","slot","useArrowNavigationGroup","useFocusFinders","useFluent_unstable","useFluent","interactionTagSecondaryClassNames","useTagGroup_unstable","props","ref","onDismiss","size","innerRef","useRef","targetDocument","findNextFocusable","findPrevFocusable","handleTagDismiss","e","data","_innerRef_current","activeElement","current","contains","next","container","focus","className","includes","root","prev","parentElement","arrowNavigationProps","circular","axis","memorizeCurrent","components","always","role","elementType"],"sources":["D:/shubh/invezza-hrm/node_modules/@fluentui/react-tags/lib/components/TagGroup/useTagGroup.js"],"sourcesContent":["import * as React from 'react';\nimport { getIntrinsicElementProps, useEventCallback, useMergedRefs, slot } from '@fluentui/react-utilities';\nimport { useArrowNavigationGroup, useFocusFinders } from '@fluentui/react-tabster';\nimport { useFluent_unstable as useFluent } from '@fluentui/react-shared-contexts';\nimport { interactionTagSecondaryClassNames } from '../InteractionTagSecondary/useInteractionTagSecondaryStyles.styles';\n/**\n * Create the state required to render TagGroup.\n *\n * The returned state can be modified with hooks such as useTagGroupStyles_unstable,\n * before being passed to renderTagGroup_unstable.\n *\n * @param props - props from this instance of TagGroup\n * @param ref - reference to root HTMLDivElement of TagGroup\n */ export const useTagGroup_unstable = (props, ref)=>{\n    const { onDismiss, size = 'medium' } = props;\n    const innerRef = React.useRef();\n    const { targetDocument } = useFluent();\n    const { findNextFocusable, findPrevFocusable } = useFocusFinders();\n    const handleTagDismiss = useEventCallback((e, data)=>{\n        var _innerRef_current;\n        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss(e, data);\n        // set focus after tag dismiss\n        const activeElement = targetDocument === null || targetDocument === void 0 ? void 0 : targetDocument.activeElement;\n        if ((_innerRef_current = innerRef.current) === null || _innerRef_current === void 0 ? void 0 : _innerRef_current.contains(activeElement)) {\n            // focus on next tag only if the active element is within the current tag group\n            const next = findNextFocusable(activeElement, {\n                container: innerRef.current\n            });\n            if (next) {\n                next.focus();\n                return;\n            }\n            // if there is no next focusable, focus on the previous focusable\n            if (activeElement === null || activeElement === void 0 ? void 0 : activeElement.className.includes(interactionTagSecondaryClassNames.root)) {\n                const prev = findPrevFocusable(activeElement.parentElement, {\n                    container: innerRef.current\n                });\n                prev === null || prev === void 0 ? void 0 : prev.focus();\n            } else {\n                const prev = findPrevFocusable(activeElement, {\n                    container: innerRef.current\n                });\n                prev === null || prev === void 0 ? void 0 : prev.focus();\n            }\n        }\n    });\n    const arrowNavigationProps = useArrowNavigationGroup({\n        circular: true,\n        axis: 'both',\n        memorizeCurrent: true\n    });\n    return {\n        handleTagDismiss,\n        size,\n        components: {\n            root: 'div'\n        },\n        root: slot.always(getIntrinsicElementProps('div', {\n            // FIXME:\n            // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`\n            // but since it would be a breaking change to fix it, we are casting ref to it's proper type\n            ref: useMergedRefs(ref, innerRef),\n            role: 'toolbar',\n            ...arrowNavigationProps,\n            ...props\n        }), {\n            elementType: 'div'\n        })\n    };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}
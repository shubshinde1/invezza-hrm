{"ast":null,"code":"import * as React from 'react';\nimport { getIntrinsicElementProps, isResolvedShorthand, useMergedRefs, slot, useEventCallback, elementContains, useControllableState } from '@fluentui/react-utilities';\nimport { useTreeItemContext_unstable, useTreeContext_unstable } from '../../contexts';\nimport { Checkbox } from '@fluentui/react-checkbox';\nimport { Radio } from '@fluentui/react-radio';\nimport { TreeItemChevron } from '../TreeItemChevron';\nimport { useArrowNavigationGroup } from '@fluentui/react-tabster';\n/**\n * Create the state required to render TreeItemLayout.\n *\n * The returned state can be modified with hooks such as useTreeItemLayoutStyles_unstable,\n * before being passed to renderTreeItemLayout_unstable.\n *\n * @param props - props from this instance of TreeItemLayout\n * @param ref - reference to root HTMLElement of TreeItemLayout\n */\nexport const useTreeItemLayout_unstable = (props, ref) => {\n  const {\n    main,\n    iconAfter,\n    iconBefore\n  } = props;\n  const layoutRef = useTreeItemContext_unstable(ctx => ctx.layoutRef);\n  const selectionMode = useTreeContext_unstable(ctx => ctx.selectionMode);\n  const [isActionsVisibleFromProps, actionsShorthand] = isResolvedShorthand(props.actions) ? [props.actions.visible, {\n    ...props.actions,\n    visible: undefined\n  }] : [undefined, props.actions];\n  const [isActionsVisible, setIsActionsVisible] = useControllableState({\n    state: isActionsVisibleFromProps,\n    initialState: false\n  });\n  const selectionRef = useTreeItemContext_unstable(ctx => ctx.selectionRef);\n  const expandIconRef = useTreeItemContext_unstable(ctx => ctx.expandIconRef);\n  const actionsRef = useTreeItemContext_unstable(ctx => ctx.actionsRef);\n  const actionsRefInternal = React.useRef(null);\n  const treeItemRef = useTreeItemContext_unstable(ctx => ctx.treeItemRef);\n  const subtreeRef = useTreeItemContext_unstable(ctx => ctx.subtreeRef);\n  const checked = useTreeItemContext_unstable(ctx => ctx.checked);\n  const isBranch = useTreeItemContext_unstable(ctx => ctx.itemType === 'branch');\n  // FIXME: Asserting is required here, as converting this to RefObject on context type would be a breaking change\n  assertIsRefObject(treeItemRef);\n  // FIXME: Asserting is required here, as converting this to RefObject on context type would be a breaking change\n  assertIsRefObject(subtreeRef);\n  const setActionsVisibleIfNotFromSubtree = React.useCallback(event => {\n    const isTargetFromSubtree = Boolean(subtreeRef.current && elementContains(subtreeRef.current, event.target));\n    if (!isTargetFromSubtree) {\n      setIsActionsVisible(true);\n    }\n  }, [subtreeRef, setIsActionsVisible]);\n  const setActionsInvisibleIfNotFromSubtree = React.useCallback(event => {\n    const isRelatedTargetFromActions = Boolean(actionsRefInternal.current && elementContains(actionsRefInternal.current, event.relatedTarget));\n    if (isRelatedTargetFromActions) {\n      setIsActionsVisible(true);\n      return;\n    }\n    const isTargetFromSubtree = Boolean(subtreeRef.current && elementContains(subtreeRef.current, event.target));\n    if (!isTargetFromSubtree) {\n      setIsActionsVisible(false);\n      return;\n    }\n  }, [subtreeRef, setIsActionsVisible]);\n  const expandIcon = slot.optional(props.expandIcon, {\n    renderByDefault: isBranch,\n    defaultProps: {\n      children: /*#__PURE__*/React.createElement(TreeItemChevron, null),\n      'aria-hidden': true\n    },\n    elementType: 'div'\n  });\n  const expandIconRefs = useMergedRefs(expandIcon === null || expandIcon === void 0 ? void 0 : expandIcon.ref, expandIconRef);\n  if (expandIcon) {\n    expandIcon.ref = expandIconRefs;\n  }\n  const arrowNavigationProps = useArrowNavigationGroup({\n    circular: true,\n    axis: 'horizontal'\n  });\n  const actions = isActionsVisible ? slot.optional(actionsShorthand, {\n    defaultProps: {\n      ...arrowNavigationProps,\n      role: 'toolbar'\n    },\n    elementType: 'div'\n  }) : undefined;\n  const actionsRefs = useMergedRefs(actions === null || actions === void 0 ? void 0 : actions.ref, actionsRef, actionsRefInternal);\n  const handleActionsBlur = useEventCallback(event => {\n    if (isResolvedShorthand(actionsShorthand)) {\n      var _actionsShorthand_onBlur;\n      (_actionsShorthand_onBlur = actionsShorthand.onBlur) === null || _actionsShorthand_onBlur === void 0 ? void 0 : _actionsShorthand_onBlur.call(actionsShorthand, event);\n    }\n    const isRelatedTargetFromActions = Boolean(elementContains(event.currentTarget, event.relatedTarget));\n    setIsActionsVisible(isRelatedTargetFromActions);\n  });\n  if (actions) {\n    actions.ref = actionsRefs;\n    actions.onBlur = handleActionsBlur;\n  }\n  const hasActions = Boolean(actionsShorthand);\n  React.useEffect(() => {\n    if (treeItemRef.current && hasActions && isActionsVisibleFromProps === undefined) {\n      const treeItemElement = treeItemRef.current;\n      const handleMouseOver = setActionsVisibleIfNotFromSubtree;\n      const handleMouseOut = setActionsInvisibleIfNotFromSubtree;\n      const handleFocus = setActionsVisibleIfNotFromSubtree;\n      const handleBlur = setActionsInvisibleIfNotFromSubtree;\n      treeItemElement.addEventListener('mouseover', handleMouseOver);\n      treeItemElement.addEventListener('mouseout', handleMouseOut);\n      treeItemElement.addEventListener('focus', handleFocus);\n      treeItemElement.addEventListener('blur', handleBlur);\n      return () => {\n        treeItemElement.removeEventListener('mouseover', handleMouseOver);\n        treeItemElement.removeEventListener('mouseout', handleMouseOut);\n        treeItemElement.removeEventListener('focus', handleFocus);\n        treeItemElement.removeEventListener('blur', handleBlur);\n      };\n    }\n  }, [hasActions, treeItemRef, isActionsVisibleFromProps, setActionsVisibleIfNotFromSubtree, setActionsInvisibleIfNotFromSubtree]);\n  return {\n    components: {\n      root: 'div',\n      expandIcon: 'div',\n      iconBefore: 'div',\n      main: 'div',\n      iconAfter: 'div',\n      actions: 'div',\n      aside: 'div',\n      // Casting here to a union between checkbox and radio\n      selector: selectionMode === 'multiselect' ? Checkbox : Radio\n    },\n    buttonContextValue: {\n      size: 'small'\n    },\n    root: slot.always(getIntrinsicElementProps('div', {\n      ...props,\n      // FIXME:\n      // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`\n      // but since it would be a breaking change to fix it, we are casting ref to it's proper type\n      ref: useMergedRefs(ref, layoutRef)\n    }), {\n      elementType: 'div'\n    }),\n    iconBefore: slot.optional(iconBefore, {\n      defaultProps: {\n        'aria-hidden': true\n      },\n      elementType: 'div'\n    }),\n    main: slot.always(main, {\n      elementType: 'div'\n    }),\n    iconAfter: slot.optional(iconAfter, {\n      defaultProps: {\n        'aria-hidden': true\n      },\n      elementType: 'div'\n    }),\n    aside: !isActionsVisible ? slot.optional(props.aside, {\n      defaultProps: {\n        'aria-hidden': true\n      },\n      elementType: 'div'\n    }) : undefined,\n    actions,\n    expandIcon,\n    selector: slot.optional(props.selector, {\n      renderByDefault: selectionMode !== 'none',\n      defaultProps: {\n        checked,\n        tabIndex: -1,\n        'aria-hidden': true,\n        ref: selectionRef\n      },\n      elementType: selectionMode === 'multiselect' ? Checkbox : Radio\n    })\n  };\n};\nfunction assertIsRefObject(ref) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof ref !== 'object' || ref === null || !('current' in ref)) {\n      throw new Error(`\n        @fluentui/react-tree [${useTreeItemLayout_unstable.name}]:\n        Internal Error: contextual ref is not a RefObject! Please report this bug immediately, as contextual refs should be RefObjects.\n      `);\n    }\n  }\n}","map":{"version":3,"names":["React","getIntrinsicElementProps","isResolvedShorthand","useMergedRefs","slot","useEventCallback","elementContains","useControllableState","useTreeItemContext_unstable","useTreeContext_unstable","Checkbox","Radio","TreeItemChevron","useArrowNavigationGroup","useTreeItemLayout_unstable","props","ref","main","iconAfter","iconBefore","layoutRef","ctx","selectionMode","isActionsVisibleFromProps","actionsShorthand","actions","visible","undefined","isActionsVisible","setIsActionsVisible","state","initialState","selectionRef","expandIconRef","actionsRef","actionsRefInternal","useRef","treeItemRef","subtreeRef","checked","isBranch","itemType","assertIsRefObject","setActionsVisibleIfNotFromSubtree","useCallback","event","isTargetFromSubtree","Boolean","current","target","setActionsInvisibleIfNotFromSubtree","isRelatedTargetFromActions","relatedTarget","expandIcon","optional","renderByDefault","defaultProps","children","createElement","elementType","expandIconRefs","arrowNavigationProps","circular","axis","role","actionsRefs","handleActionsBlur","_actionsShorthand_onBlur","onBlur","call","currentTarget","hasActions","useEffect","treeItemElement","handleMouseOver","handleMouseOut","handleFocus","handleBlur","addEventListener","removeEventListener","components","root","aside","selector","buttonContextValue","size","always","tabIndex","process","env","NODE_ENV","Error","name"],"sources":["D:/shubh/invezza-hrm/node_modules/@fluentui/react-tree/lib/components/TreeItemLayout/useTreeItemLayout.js"],"sourcesContent":["import * as React from 'react';\nimport { getIntrinsicElementProps, isResolvedShorthand, useMergedRefs, slot, useEventCallback, elementContains, useControllableState } from '@fluentui/react-utilities';\nimport { useTreeItemContext_unstable, useTreeContext_unstable } from '../../contexts';\nimport { Checkbox } from '@fluentui/react-checkbox';\nimport { Radio } from '@fluentui/react-radio';\nimport { TreeItemChevron } from '../TreeItemChevron';\nimport { useArrowNavigationGroup } from '@fluentui/react-tabster';\n/**\n * Create the state required to render TreeItemLayout.\n *\n * The returned state can be modified with hooks such as useTreeItemLayoutStyles_unstable,\n * before being passed to renderTreeItemLayout_unstable.\n *\n * @param props - props from this instance of TreeItemLayout\n * @param ref - reference to root HTMLElement of TreeItemLayout\n */ export const useTreeItemLayout_unstable = (props, ref)=>{\n    const { main, iconAfter, iconBefore } = props;\n    const layoutRef = useTreeItemContext_unstable((ctx)=>ctx.layoutRef);\n    const selectionMode = useTreeContext_unstable((ctx)=>ctx.selectionMode);\n    const [isActionsVisibleFromProps, actionsShorthand] = isResolvedShorthand(props.actions) ? [\n        props.actions.visible,\n        {\n            ...props.actions,\n            visible: undefined\n        }\n    ] : [\n        undefined,\n        props.actions\n    ];\n    const [isActionsVisible, setIsActionsVisible] = useControllableState({\n        state: isActionsVisibleFromProps,\n        initialState: false\n    });\n    const selectionRef = useTreeItemContext_unstable((ctx)=>ctx.selectionRef);\n    const expandIconRef = useTreeItemContext_unstable((ctx)=>ctx.expandIconRef);\n    const actionsRef = useTreeItemContext_unstable((ctx)=>ctx.actionsRef);\n    const actionsRefInternal = React.useRef(null);\n    const treeItemRef = useTreeItemContext_unstable((ctx)=>ctx.treeItemRef);\n    const subtreeRef = useTreeItemContext_unstable((ctx)=>ctx.subtreeRef);\n    const checked = useTreeItemContext_unstable((ctx)=>ctx.checked);\n    const isBranch = useTreeItemContext_unstable((ctx)=>ctx.itemType === 'branch');\n    // FIXME: Asserting is required here, as converting this to RefObject on context type would be a breaking change\n    assertIsRefObject(treeItemRef);\n    // FIXME: Asserting is required here, as converting this to RefObject on context type would be a breaking change\n    assertIsRefObject(subtreeRef);\n    const setActionsVisibleIfNotFromSubtree = React.useCallback((event)=>{\n        const isTargetFromSubtree = Boolean(subtreeRef.current && elementContains(subtreeRef.current, event.target));\n        if (!isTargetFromSubtree) {\n            setIsActionsVisible(true);\n        }\n    }, [\n        subtreeRef,\n        setIsActionsVisible\n    ]);\n    const setActionsInvisibleIfNotFromSubtree = React.useCallback((event)=>{\n        const isRelatedTargetFromActions = Boolean(actionsRefInternal.current && elementContains(actionsRefInternal.current, event.relatedTarget));\n        if (isRelatedTargetFromActions) {\n            setIsActionsVisible(true);\n            return;\n        }\n        const isTargetFromSubtree = Boolean(subtreeRef.current && elementContains(subtreeRef.current, event.target));\n        if (!isTargetFromSubtree) {\n            setIsActionsVisible(false);\n            return;\n        }\n    }, [\n        subtreeRef,\n        setIsActionsVisible\n    ]);\n    const expandIcon = slot.optional(props.expandIcon, {\n        renderByDefault: isBranch,\n        defaultProps: {\n            children: /*#__PURE__*/ React.createElement(TreeItemChevron, null),\n            'aria-hidden': true\n        },\n        elementType: 'div'\n    });\n    const expandIconRefs = useMergedRefs(expandIcon === null || expandIcon === void 0 ? void 0 : expandIcon.ref, expandIconRef);\n    if (expandIcon) {\n        expandIcon.ref = expandIconRefs;\n    }\n    const arrowNavigationProps = useArrowNavigationGroup({\n        circular: true,\n        axis: 'horizontal'\n    });\n    const actions = isActionsVisible ? slot.optional(actionsShorthand, {\n        defaultProps: {\n            ...arrowNavigationProps,\n            role: 'toolbar'\n        },\n        elementType: 'div'\n    }) : undefined;\n    const actionsRefs = useMergedRefs(actions === null || actions === void 0 ? void 0 : actions.ref, actionsRef, actionsRefInternal);\n    const handleActionsBlur = useEventCallback((event)=>{\n        if (isResolvedShorthand(actionsShorthand)) {\n            var _actionsShorthand_onBlur;\n            (_actionsShorthand_onBlur = actionsShorthand.onBlur) === null || _actionsShorthand_onBlur === void 0 ? void 0 : _actionsShorthand_onBlur.call(actionsShorthand, event);\n        }\n        const isRelatedTargetFromActions = Boolean(elementContains(event.currentTarget, event.relatedTarget));\n        setIsActionsVisible(isRelatedTargetFromActions);\n    });\n    if (actions) {\n        actions.ref = actionsRefs;\n        actions.onBlur = handleActionsBlur;\n    }\n    const hasActions = Boolean(actionsShorthand);\n    React.useEffect(()=>{\n        if (treeItemRef.current && hasActions && isActionsVisibleFromProps === undefined) {\n            const treeItemElement = treeItemRef.current;\n            const handleMouseOver = setActionsVisibleIfNotFromSubtree;\n            const handleMouseOut = setActionsInvisibleIfNotFromSubtree;\n            const handleFocus = setActionsVisibleIfNotFromSubtree;\n            const handleBlur = setActionsInvisibleIfNotFromSubtree;\n            treeItemElement.addEventListener('mouseover', handleMouseOver);\n            treeItemElement.addEventListener('mouseout', handleMouseOut);\n            treeItemElement.addEventListener('focus', handleFocus);\n            treeItemElement.addEventListener('blur', handleBlur);\n            return ()=>{\n                treeItemElement.removeEventListener('mouseover', handleMouseOver);\n                treeItemElement.removeEventListener('mouseout', handleMouseOut);\n                treeItemElement.removeEventListener('focus', handleFocus);\n                treeItemElement.removeEventListener('blur', handleBlur);\n            };\n        }\n    }, [\n        hasActions,\n        treeItemRef,\n        isActionsVisibleFromProps,\n        setActionsVisibleIfNotFromSubtree,\n        setActionsInvisibleIfNotFromSubtree\n    ]);\n    return {\n        components: {\n            root: 'div',\n            expandIcon: 'div',\n            iconBefore: 'div',\n            main: 'div',\n            iconAfter: 'div',\n            actions: 'div',\n            aside: 'div',\n            // Casting here to a union between checkbox and radio\n            selector: selectionMode === 'multiselect' ? Checkbox : Radio\n        },\n        buttonContextValue: {\n            size: 'small'\n        },\n        root: slot.always(getIntrinsicElementProps('div', {\n            ...props,\n            // FIXME:\n            // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`\n            // but since it would be a breaking change to fix it, we are casting ref to it's proper type\n            ref: useMergedRefs(ref, layoutRef)\n        }), {\n            elementType: 'div'\n        }),\n        iconBefore: slot.optional(iconBefore, {\n            defaultProps: {\n                'aria-hidden': true\n            },\n            elementType: 'div'\n        }),\n        main: slot.always(main, {\n            elementType: 'div'\n        }),\n        iconAfter: slot.optional(iconAfter, {\n            defaultProps: {\n                'aria-hidden': true\n            },\n            elementType: 'div'\n        }),\n        aside: !isActionsVisible ? slot.optional(props.aside, {\n            defaultProps: {\n                'aria-hidden': true\n            },\n            elementType: 'div'\n        }) : undefined,\n        actions,\n        expandIcon,\n        selector: slot.optional(props.selector, {\n            renderByDefault: selectionMode !== 'none',\n            defaultProps: {\n                checked,\n                tabIndex: -1,\n                'aria-hidden': true,\n                ref: selectionRef\n            },\n            elementType: selectionMode === 'multiselect' ? Checkbox : Radio\n        })\n    };\n};\nfunction assertIsRefObject(ref) {\n    if (process.env.NODE_ENV !== 'production') {\n        if (typeof ref !== 'object' || ref === null || !('current' in ref)) {\n            throw new Error(`\n        @fluentui/react-tree [${useTreeItemLayout_unstable.name}]:\n        Internal Error: contextual ref is not a RefObject! Please report this bug immediately, as contextual refs should be RefObjects.\n      `);\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}